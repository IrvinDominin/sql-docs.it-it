---
title: Funzione SQLSetStmtAttr | Documenti Microsoft
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: 
ms.component: odbc
ms.reviewer: 
ms.suite: sql
ms.technology: drivers
ms.tgt_pltfrm: 
ms.topic: article
apiname: SQLSetStmtAttr
apilocation: sqlsrv32.dll
apitype: dllExport
f1_keywords: SQLSetStmtAttr
helpviewer_keywords: SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
caps.latest.revision: "32"
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: On Demand
ms.openlocfilehash: be7fb7064f3e6508b481011ed2aa05068542cef9
ms.sourcegitcommit: cc71f1027884462c359effb898390c8d97eaa414
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/21/2017
---
# <a name="sqlsetstmtattr-function"></a>Funzione SQLSetStmtAttr
**Conformità**  
 Introdotta: versione ODBC 3.0 aderenza: 92 ISO  
  
 **Riepilogo**  
 **SQLSetStmtAttr** imposta gli attributi correlati a un'istruzione.  
  
> [!NOTE]  
>  Per ulteriori informazioni su cosa the Driver Manager esegue il mapping di questa funzione per quando un'applicazione ODBC 3*x* applicazione sta utilizzando un'API ODBC 2*x* driver, vedere [Mapping di funzioni di sostituzione per indietro Compatibilità delle applicazioni](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintassi  
  
```  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argomenti  
 *StatementHandle*  
 [Input] Handle di istruzione.  
  
 *Attribute*  
 [Input] Opzione per impostare, elencati in "Commenti".  
  
 *ValuePtr*  
 [Input] Valore da associare a *attributo*. A seconda del valore di *attributo*, *ValuePtr* sarà uno dei seguenti:  
  
-   Un handle di descrittore ODBC.  
  
-   Un valore SQLUINTEGER.  
  
-   Un valore SQLULEN.  
  
-   Un puntatore a uno dei seguenti:  
  
    -   Una stringa di caratteri con terminazione null.  
  
    -   Un buffer binario.  
  
    -   Un valore o una matrice di tipo SQLLEN, SQLULEN o SQLUSMALLINT.  
  
    -   Un valore definito dal driver.  
  
 Se il *attributo* argomento è un valore specifico del driver, *ValuePtr* potrebbe essere un intero con segno.  
  
 *StringLength*  
 [Input] Se *attributo* è un attributo basato su ODBC e *ValuePtr* punta a una stringa di caratteri o di un buffer binario, la lunghezza di questo argomento deve essere \* *ValuePtr*. Se *attributo* è un attributo basato su ODBC e *ValuePtr* è un numero intero, *StringLength* viene ignorato.  
  
 Se *attributo* è un attributo definito dal driver, l'applicazione indica la natura dell'attributo al Driver Manager impostando il *StringLength* argomento. *StringLength* può avere i valori seguenti:  
  
-   Se *ValuePtr* è un puntatore a una stringa di caratteri, quindi *StringLength* è la lunghezza della stringa o SQL_NTS.  
  
-   Se *ValuePtr* è un puntatore a un buffer binario, quindi viene visualizzato il risultato di SQL_LEN_BINARY_ATTR (*lunghezza*) (macro) in *StringLength*. In questo modo un valore negativo in *StringLength*.  
  
-   Se *ValuePtr* è un puntatore a un valore diverso da una stringa di caratteri o una stringa binaria, quindi *StringLength* deve avere il valore SQL_IS_POINTER.  
  
-   Se *ValuePtr* contiene un valore di lunghezza fissa, quindi *StringLength* è SQL_IS_INTEGER o SQL_IS_UINTEGER, come appropriato.  
  
## <a name="returns"></a>Valori di codice restituiti  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR o SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnostica  
 Quando **SQLSetStmtAttr** restituisce SQL_ERROR o SQL_SUCCESS_WITH_INFO, un valore SQLSTATE associato possono essere ottenuti chiamando **SQLGetDiagRec** con un *HandleType* di SQL _HANDLE_STMT e *gestire* di *StatementHandle*. Nella tabella seguente sono elencati i valori SQLSTATE comunemente restituiti da **SQLSetStmtAttr** e illustra ognuno nel contesto di questa funzione; la notazione "(DM)" precede le descrizioni di SQLSTATE restituiti da Gestione Driver. Il codice restituito associato a ogni valore SQLSTATE è SQL_ERROR, se non diversamente specificato.  
  
|SQLSTATE|Errore|Description|  
|--------------|-----------|-----------------|  
|01000|Avviso generico.|Messaggio informativo specifici del driver. (Funzione restituisce SQL_SUCCESS_WITH_INFO).|  
|01S02|Valore di opzione modificato|Il driver non supportava il valore specificato *ValuePtr*, oppure il valore specificato *ValuePtr* non valido a causa di condizioni di lavoro di implementazione, pertanto il driver sostituito con un valore analogo. (**SQLGetStmtAttr** può essere chiamato per determinare il valore di sostituzione temporaneamente.) Il valore di sostituzione è valido per il *StatementHandle* fino a quando il cursore è chiuso, a quel punto l'attributo di istruzione viene ripristinato il valore precedente. Gli attributi di istruzione che è possibile modificare sono:<br /><br /> SQL _ ATTR_CONCURRENCY SQL _ ATTR_CURSOR_TYPE SQL _ ATTR_KEYSET_SIZE SQL _ ATTR_MAX_LENGTH SQL _ ATTR_MAX_ROWS SQL _ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL _ ATTR_SIMULATE_CURSOR<br /><br /> (Funzione restituisce SQL_SUCCESS_WITH_INFO).|  
|08S01|Errore del collegamento di comunicazione|Collegamento di comunicazione tra il driver e l'origine dati a cui era connesso il driver non è stato possibile prima dell'elaborazione della funzione è stata completata.|  
|24000|Stato del cursore non valido|Il *attributo* stato SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR o SQL_ATTR_USE_BOOKMARKS e il cursore è stato aperto.|  
|HY000|Errore generale|Si è verificato un errore per cui si è verificato alcun errore SQLSTATE specifico e per cui è stato definito alcun SQLSTATE specifici dell'implementazione. Il messaggio di errore restituito da **SQLGetDiagRec** nel  *\*MessageText* buffer viene descritto l'errore e la relativa causa.|  
|HY001|Errore di allocazione della memoria|Il driver è stato in grado di allocare la memoria necessaria per supportare l'esecuzione o il completamento della funzione.|  
|HY009|Utilizzo non valido del puntatore null|Il *attributo* argomento identificato un attributo di istruzione che hanno richiesto un attributo, stringa e *ValuePtr* argomento è un puntatore null.|  
|HY010|Errore nella sequenza (funzione)|(DM) a cui è stata chiamata per l'handle di connessione associata a una funzione in modo asincrono in esecuzione il *StatementHandle*. Questa funzione asincrona era ancora in esecuzione quando il **SQLSetStmtAttr** funzione è stata chiamata.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, o **SQLMoreResults** è stato chiamato per il *StatementHandle* e restituito SQL_PARAM_DATA_ È DISPONIBILE. Questa funzione è stata chiamata prima che i dati sono stati recuperati per tutti i parametri con flusso.<br /><br /> (DM) a cui è stata chiamata per una funzione in modo asincrono in esecuzione il *StatementHandle* ed era ancora in esecuzione quando questa funzione è stata chiamata.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, o **SQLSetPos** è stato chiamato per il  *StatementHandle* e restituito SQL_NEED_DATA. Questa funzione è stata chiamata prima che sono stati inviati dati per tutti i parametri data-at-execution o colonne.|  
|HY011|Impossibile impostare l'attributo ora|Il *attributo* era SQL_ATTR_CONCURRENCY, SQL _ ATTR_CURSOR_TYPE, SQL _ ATTR_SIMULATE_CURSOR o ATTR_USE_BOOKMARKS SQL _ e l'istruzione è stata preparata.|  
|HY013|Errore di gestione della memoria|Impossibile elaborare la chiamata di funzione perché gli oggetti di memoria sottostante non è accessibile, probabilmente a causa di condizioni di memoria insufficiente.|  
|HY017|Utilizzo non valido di un handle di descrittore allocato automaticamente|(DM) il *attributo* argomento è stato SQL_ATTR_IMP_ROW_DESC o SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) il *attributo* argomento è stato SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC e il valore in *ValuePtr* originariamente un handle di descrittore allocato in modo implicito diverso da handle allocato per il ARD o APD.|  
|HY024|Valore dell'attributo non valido|Ha specificato *attributo* valore, in cui è stato specificato un valore non valido *ValuePtr*. (Gestione Driver restituisce questo SQLSTATE solo per la connessione e gli attributi di istruzione che accettano un set discreto di valori, ad esempio SQL_ATTR_ACCESS_MODE o ATTR_ASYNC_ENABLE SQL _. Per tutti gli altri connessione e gli attributi di istruzione, il driver deve verificare il valore specificato *ValuePtr*.)<br /><br /> Il *attributo* argomento è stato SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC, e *ValuePtr* è un handle di descrittore allocato in modo esplicito che non è presente nella stessa connessione, come il  *StatementHandle* argomento.|  
|HY090|Lunghezza di stringa o di buffer non valida|(DM)  *\*ValuePtr* è una stringa di caratteri e *StringLength* argomento è minore di 0 ma non è stato SQL_NTS.|  
|HY092|Identificatore di attributo/opzione non valida|(DM) il valore specificato per l'argomento *attributo* non valido per la versione di ODBC supportati dal driver.<br /><br /> (DM) il valore specificato per l'argomento *attributo* è un attributo di sola lettura.|  
|HY117|Connessione viene sospesa a causa dello stato di transazione sconosciuto. Solo disconnettersi e sono consentite funzioni di sola lettura.|(DM) per ulteriori informazioni sullo stato sospeso, vedere [funzione SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Funzionalità facoltativa non implementata.|Il valore specificato per l'argomento *attributo* è un attributo di istruzione ODBC valido per la versione di ODBC supportati dal driver, ma non è supportata dal driver.<br /><br /> Il *attributo* argomento è stato SQL_ATTR_ASYNC_ENABLE e una chiamata a **SQLGetInfo** con un *InfoType* di SQL_ASYNC_MODE restituisce SQL_AM_CONNECTION.<br /><br /> Il *attributo* argomento sia SQL_ATTR_ENABLE_AUTO_IPD e il valore dell'attributo di connessione SQL_ATTR_AUTO_IPD è SQL_FALSE.|  
|HYT01|Timeout di connessione scaduto|Il periodo di timeout di connessione scaduto prima che l'origine dati ha risposto alla richiesta. Il periodo di timeout di connessione viene impostato tramite **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Driver non supporta questa funzione|Il driver (DM) associato il *StatementHandle* non supporta la funzione.|  
|S1118|Driver non supporta la notifica asincrona|Se la chiamata **SQLSetStmtAttr** SQL_ATTR_ASYNC_STMT_EVENT; impostare la notifica asincrona non è supportata dal driver.|  
  
## <a name="comments"></a>Commenti  
 Gli attributi di istruzione per un'istruzione rimangono valide fino a quando non sono state modificate da un'altra chiamata a **SQLSetStmtAttr** o fino a quando non viene eliminata l'istruzione chiamando **SQLFreeHandle**. La chiamata **SQLFreeStmt** con SQL_CLOSE, SQL_UNBIND o SQL_RESET_PARAMS opzione non consente di ripristinare gli attributi di istruzione.  
  
 Alcuni attributi di istruzione supportano la sostituzione di un valore simile, se l'origine dati non supporta il valore specificato *ValuePtr*. In questi casi, il driver restituisce SQL_SUCCESS_WITH_INFO e SQLSTATE 01S02 (valore di opzione modificato). Ad esempio, se *attributo* è SQL_ATTR_CONCURRENCY e *ValuePtr* SQL_CONCUR_ROWVER, e se l'origine dati non supporta questo, il driver sostituisce SQL_CONCUR_VALUES restituisce SQL _ SUCCESS_WITH_INFO. Per determinare il valore di sostituzione, un'applicazione chiama **SQLGetStmtAttr**.  
  
 Imposta il formato delle informazioni con *ValuePtr* dipende specificato *attributo*. **SQLSetStmtAttr** accetta informazioni sugli attributi in uno dei due formati: una stringa di caratteri o un valore intero. Il formato di ogni viene indicato nella descrizione dell'attributo. Questo formato si applica alle informazioni restituite per ogni attributo **SQLGetStmtAttr**. A cui puntate stringhe di caratteri di *ValuePtr* argomento di **SQLSetStmtAttr** avere una lunghezza di *StringLength*.  
  
> [!NOTE]  
>  La possibilità di impostare gli attributi di istruzione a livello di connessione chiamando **SQLSetConnectAttr** è stato deprecato in ODBC 3*x*. ODBC 3*x* applicazioni non devono mai impostata gli attributi di istruzione a livello di connessione. ODBC 3*x* gli attributi di istruzione non possono essere impostati a livello di connessione, fatta eccezione per gli attributi SQL_ATTR_METADATA_ID e SQL_ATTR_ASYNC_ENABLE, sia gli attributi di connessione e gli attributi di istruzione, che può essere impostare il livello di connessione o il livello di istruzione.  
  
> [!NOTE]  
>  ODBC 3*x* driver necessitano supportano questa funzionalità solo se funzionano con ODBC 2*x* applicazione che imposta ODBC 2*x* opzioni dell'istruzione a livello di connessione. Per ulteriori informazioni, vedere "Impostazione istruzione opzioni sul livello di connessione" nella sezione [SQLSetConnectOption Mapping](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) nell'appendice g: Driver le linee guida per la compatibilità con le versioni precedenti.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Attributi di istruzione che impostano i campi di descrizione  
 Numero di attributi di istruzione corrisponde a un campo di intestazione di un descrittore. Impostando questi attributi effettivamente i risultati in base alle impostazioni di campi di descrizione. Impostazione dei campi da una chiamata a **SQLSetStmtAttr** anziché a **SQLSetDescField** ha il vantaggio che un handle di descrittore non deve essere ottenuto per la chiamata di funzione.  
  
> [!CAUTION]  
>  La chiamata **SQLSetStmtAttr** per un'istruzione può influire sulle altre istruzioni. Questo errore si verifica quando il APD o ARD associate all'istruzione viene allocato in modo esplicito ed è anche associato con altre istruzioni. Poiché **SQLSetStmtAttr** modifica il APD o ARD, le modifiche si applicano a tutte le istruzioni a cui è associato questo descrittore. In caso contrario il comportamento richiesto, l'applicazione deve annullare l'associazione di questo descrittore da altre istruzioni (chiamando **SQLSetStmtAttr** per impostare il campo SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC a un altro handle di descrittore) prima di chiamare **SQLSetStmtAttr** nuovamente.  
  
 Quando un campo di descrizione è impostato come risultato l'attributo di istruzione corrispondente viene impostato, il campo viene impostato solo per i descrittori applicabili attualmente associati con l'istruzione identificata le *StatementHandle* argomento e l'impostazione dell'attributo non influiscono su qualsiasi descrittori che possono essere associati a tale istruzione in futuro. Quando un campo di descrizione che è anche un attributo dell'istruzione è impostato da una chiamata a **SQLSetDescField**, viene impostato l'attributo di istruzione corrispondente. Se l'associazione è un descrittore allocato in modo esplicito viene annullato da un'istruzione, un attributo di istruzione che corrisponde a un campo di intestazione verrà ripristinato il valore del campo di descrittore allocato in modo implicito.  
  
 Quando un'istruzione viene allocata (vedere [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), quattro handle di descrittore allocati e associati all'istruzione automaticamente. Gli handle di descrittore allocato in modo esplicito possono essere associati con l'istruzione chiamando **SQLAllocHandle** con un *fHandleType* di SQL_HANDLE_DESC per allocare un handle di descrittore e quindi chiamando  **SQLSetStmtAttr** per associare l'handle di descrittore con l'istruzione.  
  
 Gli attributi dell'istruzione nella tabella riportata di seguito corrispondono ai campi di intestazione del descrittore.  
  
|Attributo di istruzione|Campo di intestazione|DESC.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ARD|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ARD|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ARD|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ARD|  
|VENGONO IMPOSTATI SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Attributi di istruzione  
 Gli attributi attualmente definiti e la versione di ODBC in cui sono state introdotte vengono visualizzati nella tabella seguente. è previsto che verranno definiti più attributi dai driver per sfruttare i vantaggi di origini dati diverse. Un intervallo di attributi è riservato da ODBC. gli sviluppatori di driver è necessario riservare i valori per l'uso di specifici del driver da Open Group. Per ulteriori informazioni, vedere [tipi di dati specifici del Driver, descrittore di tipi, tipi di informazioni, tipi di diagnostica e gli attributi](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|attribute|*ValuePtr* contenuto|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|L'handle per le chiamate successive a APD **SQLExecute** e **SQLExecDirect** nell'handle di istruzione. Il valore iniziale di questo attributo è il descrittore allocato in modo implicito quando l'istruzione è stata allocata inizialmente. Se il valore di questo attributo è impostato su SQL_NULL_DESC o l'handle allocata inizialmente per il descrittore, un handle APD allocato in modo esplicito che era precedentemente associato l'handle di istruzione dissociato e l'handle di istruzione viene ripristinata la in modo implicito allocato handle APD.<br /><br /> Questo attributo non può essere impostato su un handle di descrittore allocato in modo implicito per un'altra istruzione o a un altro handle di descrittore che è stato impostato in modo implicito nella stessa istruzione. gli handle di descrittore allocato in modo implicito non possono essere associati più di un'istruzione o un handle descrittore.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Handle di ARD per recuperi successivi nell'handle di istruzione. Il valore iniziale di questo attributo è il descrittore allocato in modo implicito quando l'istruzione è stata allocata inizialmente. Se il valore di questo attributo è impostato su SQL_NULL_DESC o l'handle allocata inizialmente per il descrittore, un handle ARD allocato in modo esplicito che era precedentemente associato l'handle di istruzione dissociato e l'handle di istruzione viene ripristinata la in modo implicito allocato handle ARD.<br /><br /> Questo attributo non può essere impostato su un handle di descrittore allocato in modo implicito per un'altra istruzione o a un altro handle di descrittore che è stato impostato in modo implicito nella stessa istruzione. gli handle di descrittore allocato in modo implicito non possono essere associati più di un'istruzione o un handle descrittore.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Un valore SQLULEN che specifica se una funzione chiamata con l'istruzione specificata viene eseguita in modo asincrono:<br /><br /> SQL_ASYNC_ENABLE_OFF = supporto livello esecuzione asincrona dell'istruzione Disable (impostazione predefinita).<br /><br /> SQL_ASYNC_ENABLE_ON = abilitazione del supporto livello esecuzione asincrona dell'istruzione.<br /><br /> Per ulteriori informazioni, vedere [esecuzione asincrona (metodo di Polling)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Per i driver con supporto livello esecuzione asincrona dell'istruzione, l'attributo di istruzione SQL_ATTR_ASYNC_ENABLE è di sola lettura. Il valore è identico al valore dell'attributo di livello di connessione con lo stesso nome al momento che dell'handle di istruzione è stata allocata.<br /><br /> La chiamata **SQLSetStmtAttr** per impostare SQL_ATTR_ASYNC_ENABLE quando il SQL_ASYNC_MODE *InfoType* restituisce SQL_AM_CONNECTION HYC00 SQLSTATE (funzionalità facoltativa non implementata). Per ulteriori informazioni, vedere [funzione SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) per ulteriori informazioni.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Valore SQLPOINTER che è un handle di evento.<br /><br /> Notifica del completamento di funzioni asincrone è abilitata per la chiamata **SQLSetStmtAttr** per impostare il **SQL_ATTR_ASYNC_STMT_EVENT** attributo e specificare l'handle dell'evento.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|SQLPOINTER alla funzione di callback asincrono.<br /><br /> Solo in Gestione Driver può chiamare un driver **SQLSetStmtAttr** funzione con questo attributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Un SQLPOINTER alla struttura di contesto<br /><br /> Solo in Gestione Driver può chiamare un driver **SQLSetStmtAttr** funzione con questo attributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Valore SQLULEN che specifica la concorrenza dei cursori:<br /><br /> SQL_CONCUR_READ_ONLY = cursore è di sola lettura. Non sono consentiti aggiornamenti.<br /><br /> SQL_CONCUR_LOCK = cursore utilizza il livello più basso di blocco sufficiente a garantire che la riga può essere aggiornata.<br /><br /> SQL_CONCUR_ROWVER = controllo della concorrenza ottimistica utilizza cursori, confrontare le versioni di riga, ad esempio SQLBase ROWID o Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = controllo della concorrenza ottimistica utilizza cursori, il confronto di valori.<br /><br /> Il valore predefinito per SQL_ATTR_CONCURRENCY è SQL_CONCUR_READ_ONLY.<br /><br /> Questo attributo non può essere specificato per un cursore aperto. Per ulteriori informazioni, vedere [tipi di concorrenza](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Se il SQL_ATTR_CURSOR_TYPE *attributo* viene modificato in un tipo che non supporta il valore corrente di SQL_ATTR_CONCURRENCY, il valore di SQL_ATTR_CONCURRENCY verrà modificato in fase di esecuzione e visualizzato quando un avviso **SQLExecDirect** o **SQLPrepare** viene chiamato.<br /><br /> Se il driver supporta la **SELECT FOR UPDATE** e tali un'istruzione viene eseguita quando il valore di SQL_ATTR_CONCURRENCY è impostato su SQL_CONCUR_READ_ONLY, verrà restituito un errore. Se il valore di SQL_ATTR_CONCURRENCY viene modificato un valore che il driver supporta per alcuni valori di SQL_ATTR_CURSOR_TYPE ma non per il valore corrente di SQL_ATTR_CURSOR_TYPE, il valore di SQL_ATTR_CURSOR_TYPE verrà modificato in fase di esecuzione e 01S02 SQLSTATE (Valore di opzione modificato) viene generato quando **SQLExecDirect** o **SQLPrepare** viene chiamato.<br /><br /> Se la concorrenza specificata non è supportata dall'origine dati, il driver sostituisce una concorrenza diversi e restituisce SQLSTATE 01S02 (valore di opzione modificato). Per SQL_CONCUR_VALUES, il driver sostituisce SQL_CONCUR_ROWVER e viceversa. Per SQL_CONCUR_LOCK, il driver sostituisce, in ordine, SQL_CONCUR_ROWVER o SQL_CONCUR_VALUES. La validità del valore sostituito non viene verificata fino a quando il tempo di esecuzione.<br /><br /> Per ulteriori informazioni sulla relazione tra SQL_ATTR_CONCURRENCY e gli altri attributi del cursore, vedere [delle caratteristiche del cursore e tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Valore SQLULEN che specifica il livello di supporto che richiede l'applicazione. Impostazione di questo attributo influisce sulle chiamate successive a **SQLExecDirect** e **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = Scrollable cursori non sono richieste per l'handle di istruzione. Se l'applicazione chiama **SQLFetchScroll** su questo handle, l'unico valore valido di *FetchOrientation* è SQL_FETCH_NEXT. Impostazione predefinita.<br /><br /> SQL_SCROLLABLE = Scrollable cursori sono necessarie per l'handle di istruzione. Quando si chiama **SQLFetchScroll**, l'applicazione può specificare qualsiasi valore valido di *FetchOrientation*, ottenere il posizionamento del cursore in modalità diverse da modalità sequenziale.<br /><br /> Per ulteriori informazioni sui cursori scorrevoli, vedere [cursori scorrevoli](../../../odbc/reference/develop-app/scrollable-cursors.md). Per ulteriori informazioni sulla relazione tra SQL_ATTR_CURSOR_SCROLLABLE e gli altri attributi del cursore, vedere [delle caratteristiche del cursore e tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Valore SQLULEN che specifica se i cursori dell'handle di istruzione rendere visibili le modifiche apportate a un risultato impostato da un altro cursore. Impostazione di questo attributo influisce sulle chiamate successive a **SQLExecDirect** e **SQLExecute**. Un'applicazione di leggere nuovamente il valore di questo attributo per ottenere lo stato iniziale o il relativo stato come più recente impostato dall'applicazione.<br /><br /> SQL_UNSPECIFIED = non è specificato che cos'è il tipo di cursore e se i cursori dell'handle di istruzione rendere visibili le modifiche apportate a un gruppo di risultati da un altro cursore. I cursori dell'handle di istruzione potrebbero rendere visibili nessuno, alcuni o tutti tali modifiche. Impostazione predefinita.<br /><br /> SQL_INSENSITIVE = tutti i cursori la presentazione di handle di istruzione il set di risultati senza che riflette le modifiche apportate da qualsiasi altro tipo di cursore. I cursori distinzione sono di sola lettura. Corrisponde a un cursore statico, che ha una concorrenza che è di sola lettura.<br /><br /> SQL_SENSITIVE = tutti i cursori di istruzione handle rendere visibile impostare tutte le modifiche apportate a un risultato da un altro cursore.<br /><br /> Per ulteriori informazioni sulla relazione tra SQL_ATTR_CURSOR_SENSITIVITY e gli altri attributi del cursore, vedere [delle caratteristiche del cursore e tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Valore SQLULEN che specifica il tipo di cursore:<br /><br /> SQL_CURSOR_FORWARD_ONLY = il cursore solo scorre verso il rollforward.<br /><br /> SQL_CURSOR_STATIC = i dati del risultato è statico.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = i salvataggi dei driver e utilizza le chiavi per il numero di righe specificato nell'attributo di istruzione SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC = i salvataggi dei driver e utilizza solo le chiavi per le righe nel set di righe.<br /><br /> Il valore predefinito è SQL_CURSOR_FORWARD_ONLY. Questo attributo non può essere specificato dopo l'istruzione SQL è stata preparata.<br /><br /> Se il tipo di cursore specificato non è supportato dall'origine dati, il driver sostituisce un tipo di cursore diverso e restituisce SQLSTATE 01S02 (valore di opzione modificato). Per un cursore dinamico o misto, il driver sostituisce, in ordine, un cursore keyset o statico. Cursori basati su keyset, il driver sostituisce un cursore statico.<br /><br /> Per ulteriori informazioni sui tipi di cursore scorrevole, vedere [tipi di cursore scorrevole](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Per ulteriori informazioni sulla relazione tra SQL_ATTR_CURSOR_TYPE e gli altri attributi del cursore, vedere [delle caratteristiche del cursore e tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Un valore SQLULEN che specifica se viene eseguita la compilazione automatica del IPD:<br /><br /> SQL_TRUE = attiva sul popolamento automatico del IPD dopo una chiamata a **SQLPrepare**. SQL_FALSE = consente di disattivare il popolamento automatico del IPD dopo una chiamata a **SQLPrepare**. (Un'applicazione può comunque ottenere informazioni sui campi IPD chiamando **SQLDescribeParam**, se supportata.) Il valore predefinito dell'attributo di istruzione SQL_ATTR_ENABLE_AUTO_IPD è SQL_FALSE. Per ulteriori informazioni, vedere [il popolamento automatico il IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Un SQLLEN \* che punta a un valore binario segnalibro. Quando **SQLFetchScroll** viene chiamato con *fFetchOrientation* uguale a SQL_FETCH_BOOKMARK, il driver preleva il valore del segnalibro da questo campo. Questo campo viene automaticamente a un puntatore null. Per ulteriori informazioni, vedere [scorrimento dal segnalibro](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Il valore a cui fa riferimento questo campo non viene utilizzato per l'eliminazione dal segnalibro, aggiornare dal segnalibro o recuperare dalle operazioni segnalibro **SQLBulkOperations**, che utilizzano i segnalibri memorizzati nella cache nel buffer di set di righe.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Handle di IPD. Il valore di questo attributo è il descrittore allocato quando l'istruzione è stata allocata inizialmente. L'applicazione non è possibile impostare questo attributo.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** ma non è stato impostato da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Handle di implementazione. Il valore di questo attributo è il descrittore allocato quando l'istruzione è stata allocata inizialmente. L'applicazione non è possibile impostare questo attributo.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** ma non è stato impostato da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Un SQLULEN che specifica il numero di righe nel keyset per un cursore gestito da keyset. Se la dimensione del keyset è 0 (impostazione predefinita), il cursore è completamente basati su keyset. Se la dimensione del keyset è maggiore di 0, il cursore è misto (keyset all'interno del keyset e dinamici di fuori di keyset). La dimensione del keyset predefinito è 0. Per ulteriori informazioni sui cursori basati su keyset, vedere [cursori gestiti da keyset](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Se le dimensioni specificate superano la dimensione del keyset massimo, il driver sostituisce tali dimensioni e restituisce SQLSTATE 01S02 (valore di opzione modificato).<br /><br /> **SQLFetch** o **SQLFetchScroll** restituisce un errore se la dimensione del keyset è maggiore di 0 e minore della dimensione del set di righe.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Valore SQLULEN che specifica la quantità massima di dati che il driver restituisce da un carattere o una colonna di dati binari. Se *ValuePtr* è minore della lunghezza dei dati disponibili, **SQLFetch** o **SQLGetData** tronca i dati e restituisce SQL_SUCCESS. Se *ValuePtr* è 0 (impostazione predefinita), il driver tenta di restituire tutti i dati disponibili.<br /><br /> Se la lunghezza specificata è inferiore alla quantità minima di dati che può restituire l'origine dati o maggiore rispetto alla quantità massima di dati che può restituire l'origine dati, la sostituzione di driver che il valore e restituisce SQLSTATE 01S02 (valore di opzione modificato).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto. Tuttavia, l'impostazione potrebbe non hanno effetto immediatamente, in qual caso il driver restituirà 01S02 SQLSTATE (valore di opzione modificato) e reimpostare l'attributo al valore originale.<br /><br /> Questo attributo è progettato per ridurre il traffico di rete e deve essere supportato solo quando l'origine dati (a differenza dei driver) di un driver a più livelli è possibile implementarla. Questo meccanismo non deve essere utilizzato dalle applicazioni per troncare i dati; per troncare i dati ricevuti, un'applicazione deve specificare la lunghezza massima del buffer nel *BufferLength* argomento **SQLBindCol** o **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Un valore SQLULEN corrispondente al numero massimo di righe da restituire all'applicazione per un **selezionare** istruzione. Se \* *ValuePtr* è uguale a 0 (impostazione predefinita), il driver restituisce tutte le righe.<br /><br /> Questo attributo è progettato per ridurre il traffico di rete. Concettualmente, viene applicato quando il set di risultati viene creato e limita il set di risultati al primo *ValuePtr* righe. Se il numero di righe nel set di risultati è maggiore di *ValuePtr*, il set di risultati viene troncato.<br /><br /> SQL_ATTR_MAX_ROWS applica a tutti i set di risultati di *istruzione*, inclusi quelli restituiti dalle funzioni di catalogo. SQL_ATTR_MAX_ROWS stabilisce un limite massimo per il valore del numero di riga del cursore.<br /><br /> Un driver non deve emulare il comportamento SQL_ATTR_MAX_ROWS per **SQLFetch** o **SQLFetchScroll** (se limitazioni delle dimensioni dei set di risultati non è possibile implementare nell'origine dati) se non è possibile garantire che sql_attr MAX_ROWS verrà implementato correttamente.<br /><br /> È definito dal driver se SQL_ATTR_MAX_ROWS si applica alle istruzioni diverso da istruzioni SELECT (ad esempio le funzioni di catalogo).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto. Tuttavia, l'impostazione potrebbe non hanno effetto immediatamente, in qual caso il driver restituirà 01S02 SQLSTATE (valore di opzione modificato) e reimpostare l'attributo al valore originale.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Un valore SQLULEN che determina come vengono trattati gli argomenti stringa di funzioni di catalogo.<br /><br /> Se SQL_TRUE, l'argomento di stringa delle funzioni di catalogo vengono considerati come identificatori. Nel caso non è significativo. Per le stringhe non delimitate, il driver rimuove gli spazi finali e viene ridotta la stringa in lettere maiuscole. Per le stringhe delimitate, il driver rimuove gli spazi iniziali o finali e accetta qualsiasi è racchiuso tra i delimitatori letteralmente. Se uno di questi argomenti è impostato su un puntatore null, la funzione restituisce SQL_ERROR e SQLSTATE HY009 (utilizzo non valido del puntatore null).<br /><br /> Se SQL_FALSE, gli argomenti stringa di funzioni di catalogo non vengono considerati come identificatori. Il case è significativo. Essi possono contenere un criterio di ricerca stringa oppure No, a seconda dell'argomento.<br /><br /> Il valore predefinito è SQL_FALSE.<br /><br /> Il *TableType* argomento di **SQLTables**, che accetta un elenco di valori, non è interessato da questo attributo.<br /><br /> SQL_ATTR_METADATA_ID può anche essere impostati a livello di connessione. (E SQL_ATTR_ASYNC_ENABLE sono gli attributi di istruzione che sono anche gli attributi di connessione).<br /><br /> Per ulteriori informazioni, vedere [argomenti delle funzioni di catalogo in](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Un valore SQLULEN che indica se il driver deve analizzare le stringhe SQL per le sequenze di escape:<br /><br /> SQL_NOSCAN_OFF = le analisi di driver stringhe SQL per le sequenze di escape (impostazione predefinita).<br /><br /> SQL_NOSCAN_ON = il driver non esegue la scansione stringhe SQL per le sequenze di escape. Al contrario, il driver invia l'istruzione direttamente all'origine dati.<br /><br /> Per ulteriori informazioni, vedere [sequenze di Escape ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valore che punta a un offset aggiunto ai puntatori a modificare l'associazione di parametri dinamici. Se questo campo è non null, il driver Dereferenzia il puntatore, aggiunge il valore dereferenziato a ognuno dei campi posticipati nel record del descrittore (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e utilizza i nuovi valori di puntatore durante l'associazione. È impostato su null per impostazione predefinita.<br /><br /> L'offset di binding viene sempre aggiunto direttamente ai campi SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR. Se l'offset viene modificato in un valore diverso, il nuovo valore risulta ancora aggiunto direttamente al valore nel campo del descrittore. Il nuovo offset non viene aggiunto per il valore del campo e per qualsiasi offset precedente.<br /><br /> Per ulteriori informazioni, vedere [parametro associazione offset](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_BIND_OFFSET_PTR nell'intestazione APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Valore SQLULEN che indica l'orientamento di associazione da utilizzare per i parametri dinamici.<br /><br /> Questo campo è impostato su SQL_PARAM_BIND_BY_COLUMN (predefinito) per selezionare l'associazione per colonna.<br /><br /> Per selezionare l'associazione per riga, questo campo è impostato sulla lunghezza della struttura o un'istanza di un buffer che verrà associato a un set di parametri dinamici. Questa lunghezza deve includere lo spazio per tutti i parametri associati ed eventuale riempimento della struttura o del buffer per garantire che quando l'indirizzo di un parametro associato viene incrementato con la lunghezza specificata, il risultato punterà all'inizio del parametro stesso nella prossima set di parametri. Quando si utilizza il *sizeof* operatore in ANSI C, questo comportamento è garantito.<br /><br /> Per ulteriori informazioni, vedere [associazione di matrici di parametri](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ BIND_TYPE nell'intestazione APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valore che punta a una matrice di valori SQLUSMALLINT utilizzato per ignorare un parametro durante l'esecuzione di un'istruzione SQL. Ogni valore è impostato su SQL_PARAM_PROCEED (per il parametro deve essere eseguito) o SQL_PARAM_IGNORE (per il parametro verrà ignorato).<br /><br /> Un set di parametri può essere ignorato durante l'elaborazione impostando il valore di stato nella matrice a cui puntata SQL_DESC_ARRAY_STATUS_PTR in APD per SQL_PARAM_IGNORE. Se il valore di stato è impostato su SQL_PARAM_PROCEED o se nessun elemento nella matrice è impostato, viene elaborato un set di parametri.<br /><br /> Questo attributo istruzione può essere impostato su un puntatore null, in cui i casi il driver non restituiscono parametri i valori di stato. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva **SQLExecDirect** o **SQLExecute** viene chiamato.<br /><br /> Questo attributo viene ignorato quando è presente alcun parametro associato.<br /><br /> Per ulteriori informazioni, vedere [utilizzando matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valore che punta a una matrice di SQLUSMALLINT valori contenente le informazioni di stato per ogni riga di valori di parametro dopo una chiamata a **SQLExecute** o **SQLExecDirect**. Questo campo è obbligatorio solo se PARAMSET_SIZE è maggiore di 1.<br /><br /> I valori di stato possono contenere i seguenti valori:<br /><br /> SQL_PARAM_SUCCESS: L'istruzione SQL è stata eseguita correttamente per questo set di parametri.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: L'istruzione SQL è stata eseguita correttamente per questo set di parametri. Tuttavia, le informazioni sull'avviso è disponibile nella struttura di dati di diagnostica.<br /><br /> SQL_PARAM_ERROR: Si è verificato un errore durante l'elaborazione di questo set di parametri. Informazioni aggiuntive sull'errore è disponibile nella struttura di dati di diagnostica.<br /><br /> SQL_PARAM_UNUSED: Il set di parametri è stato inutilizzato, probabilmente dovuto al fatto che alcuni set di parametri precedente ha causato un errore che ha interrotto l'ulteriore elaborazione o SQL_PARAM_IGNORE è stato impostato per tale set di parametri nella matrice specificata per il SQL_ATTR_PARAM_ OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: Il driver considera le matrici di parametri come un'unità monolitica e pertanto non genera questo livello di informazioni sull'errore.<br /><br /> Questo attributo istruzione può essere impostato su un puntatore null, in cui i casi il driver non restituiscono parametri i valori di stato. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva **SQLExecute** o **SQLExecDirect** viene chiamato. Si noti che l'impostazione di questo attributo può influenzare il comportamento di parametro di output implementato dal driver.<br /><br /> Per ulteriori informazioni, vedere [utilizzando matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Un SQLULEN \* campi di record che punta a un buffer in cui restituire il numero di set di parametri che sono stati elaborati, compresi i set di errore. Se si tratta di un puntatore null, non verrà restituito alcun numero.<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ROWS_PROCESSED_PTR nell'intestazione IPD.<br /><br /> Se la chiamata a **SQLExecDirect** o **SQLExecute** che operazioni di inserimento nel buffer a cui fa riferimento questo attributo non viene restituito SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, il contenuto del buffer non è definito.<br /><br /> Per ulteriori informazioni, vedere [utilizzando matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Valore SQLULEN che specifica il numero di valori per ogni parametro. Se SQL_ATTR_PARAMSET_SIZE è maggiore di 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR del punto di APD alle matrici. La cardinalità di ogni matrice è uguale al valore di questo campo.<br /><br /> Questo attributo viene ignorato quando è presente alcun parametro associato.<br /><br /> Per ulteriori informazioni, vedere [utilizzando matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_SIZE nell'intestazione APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Un valore SQLULEN corrispondente al numero di secondi di attesa di un'istruzione SQL da eseguire prima di restituire l'applicazione. Se *ValuePtr* è uguale a 0 (impostazione predefinita), non vi è alcun timeout.<br /><br /> Se il timeout specificato supera il timeout massimo nell'origine dati o è inferiore rispetto al timeout minimo, **SQLSetStmtAttr** sostituisce il valore e restituisce SQLSTATE 01S02 (valore di opzione modificato).<br /><br /> Si noti che l'applicazione non è necessario chiamare **SQLCloseCursor** di riutilizzare l'istruzione, se un **selezionare** timeout dell'istruzione.<br /><br /> Il timeout di query impostato nell'attributo istruzione è valido in modalità sincrone e asincrone.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Un valore SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** e, in ODBC 3*x*, **SQLFetch** recuperare dati dopo il cursore viene posizionato nel percorso specificato. Impostazione predefinita.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** e, in ODBC 3*x*, **SQLFetch** non recuperare i dati dopo il cursore viene posizionato.<br /><br /> Impostazione SQL_RETRIEVE_DATA SQL_RD_OFF, un'applicazione può verificare che una riga esistente o recuperare un segnalibro per la riga senza l'overhead di recupero di righe. Per ulteriori informazioni, vedere [scorrimento e recupero di righe](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto. Tuttavia, l'impostazione potrebbe non hanno effetto immediatamente, in qual caso il driver restituirà 01S02 SQLSTATE (valore di opzione modificato) e reimpostare l'attributo al valore originale.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Un valore SQLULEN che specifica il numero di righe restituite da ogni chiamata a **SQLFetch** o **SQLFetchScroll**. È anche il numero di righe in una matrice di segnalibro utilizzata in un'operazione di segnalibro bulk in **SQLBulkOperations**. Il valore predefinito è 1.<br /><br /> Se le dimensioni del set di righe specificato superano le dimensioni del set di righe massimo supportata dall'origine dati, il driver sostituisce il valore e restituisce SQLSTATE 01S02 (valore di opzione modificato).<br /><br /> Per ulteriori informazioni, vedere [dimensioni del set di righe](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_SIZE nell'intestazione ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valore che punta a un offset aggiunto ai puntatori a modificare l'associazione di dati della colonna. Se questo campo è non null, il driver Dereferenzia il puntatore, aggiunge il valore dereferenziato a ognuno dei campi posticipati nel record del descrittore (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e utilizza i nuovi valori di puntatore durante l'associazione. È impostato su null per impostazione predefinita.<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_BIND_OFFSET_PTR nell'intestazione ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Valore SQLULEN che imposta l'orientamento di associazione da utilizzare quando **SQLFetch** o **SQLFetchScroll** viene chiamato su istruzione associata. L'associazione è selezionata per l'impostazione del valore su SQL_BIND_BY_COLUMN. L'associazione per riga è selezionata, impostando il valore per la lunghezza di una struttura o un'istanza di un buffer in cui le colonne di risultati verranno associate.<br /><br /> Se viene specificata una lunghezza, deve includere lo spazio per tutte le colonne associate ed eventuale riempimento della struttura o del buffer per garantire che quando l'indirizzo di una colonna associata viene incrementato con la lunghezza specificata, il risultato punterà all'inizio della stessa colonna della posizione riga successiva e. Quando si utilizza il **sizeof** operatore con strutture o unioni in ANSI C, questo comportamento è garantito.<br /><br /> L'associazione è l'orientamento di associazione predefinito per **SQLFetch** e **SQLFetchScroll**.<br /><br /> Per ulteriori informazioni, vedere [associazione delle colonne per l'utilizzo con i cursori a blocchi](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_BIND_TYPE nell'intestazione ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Imposta un valore SQLULEN che corrisponde al numero della riga corrente nel risultato intero. Se non è possibile determinare il numero della riga corrente o è presente alcuna riga corrente, il driver restituisce 0.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** ma non è stato impostato da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valore che punta a una matrice di valori SQLUSMALLINT utilizzato per ignorare una riga durante un'operazione bulk usando **SQLSetPos**. Ogni valore è impostato su SQL_ROW_PROCEED (per la riga da includere nell'operazione di massa) o SQL_ROW_IGNORE (per la riga da escludere dall'operazione di massa). (Righe non possono essere ignorate utilizzando la matrice durante le chiamate ad **SQLBulkOperations**.)<br /><br /> Questo attributo istruzione può essere impostato su un puntatore null, nel quale caso il driver non restituisce valori di stato di riga. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva **SQLSetPos** viene chiamato.<br /><br /> Per ulteriori informazioni, vedere [l'aggiornamento di righe nel set di righe con SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) e [l'eliminazione di righe nel set di righe con SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR il ARD.|  
|VENGONO IMPOSTATI SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valore che punta a una matrice di SQLUSMALLINT valori che contengono i valori di stato di riga dopo una chiamata a **SQLFetch** o **SQLFetchScroll**. La matrice dispone di molti elementi sono presenti righe nel set di righe.<br /><br /> Questo attributo istruzione può essere impostato su un puntatore null, nel quale caso il driver non restituisce valori di stato di riga. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, o  **SQLSetPos** viene chiamato.<br /><br /> Per ulteriori informazioni, vedere [numero di righe recuperate e lo stato](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione IRD.<br /><br /> Questo attributo è associato a una ODBC 2*x* driver per il *rgbRowStatus* matrice in una chiamata a **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Un SQLULEN \* che punta a un buffer in cui restituire il numero di righe recuperate dopo una chiamata a **SQLFetch** o **SQLFetchScroll**; il numero di righe interessate da un'operazione bulk eseguite da una chiamata a **SQLSetPos** con un *operazione* argomento SQL_REFRESH; o il numero di righe interessate da un'operazione bulk eseguita da **SQLBulkOperations**. Questo numero include le righe di errore.<br /><br /> Per ulteriori informazioni, vedere [numero di righe recuperate e lo stato](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ROWS_PROCESSED_PTR nell'intestazione IRD.<br /><br /> Se la chiamata a **SQLFetch** o **SQLFetchScroll** che operazioni di inserimento nel buffer a cui fa riferimento questo attributo non viene restituito SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, il contenuto del buffer non è definito.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Un valore che specifica se i driver che simulano posizionati istruzioni update e delete di SQLULEN garantisce che tali istruzioni interessano solo un'unica riga.<br /><br /> Per simulare aggiornamento posizionato e istruzioni delete, la maggior parte dei driver costruire una ricerca **aggiornare** o **eliminare** istruzione contenente un **dove** clausola che specifica il valore di ogni colonna nella riga corrente. A meno che queste colonne è costituiscono una chiave univoca, tale istruzione può influenzare più di una riga.<br /><br /> Per garantire che tali istruzioni interessano solo una riga, il driver determina le colonne in una chiave univoca e aggiunge tali colonne al set di risultati. Se un'applicazione garantisce che le colonne nel set di risultati costituiscono una chiave univoca, il driver non è necessario eseguire questa operazione. Questo potrebbe ridurre il tempo di esecuzione.<br /><br /> SQL_SC_NON_UNIQUE = il driver non garantisce che simulato posizionato aggiornamento o le istruzioni delete influirà solo una riga. è responsabilità dell'applicazione a tale scopo. Se un'istruzione interessa più di una riga, **SQLExecute**, **SQLExecDirect**, o **SQLSetPos** restituisce SQLSTATE 01001 (conflitto dell'operazione del cursore).<br /><br /> SQL_SC_TRY_UNIQUE = i tentativi di driver per garantire che simulato posizionato aggiornamento o eliminazione di istruzioni interessano solo una riga. Il driver esegue sempre tali istruzioni, anche se che potrebbero influire su più righe, ad esempio quando è presente alcuna chiave univoca. Se un'istruzione interessa più di una riga, **SQLExecute**, **SQLExecDirect**, o **SQLSetPos** restituisce SQLSTATE 01001 (conflitto dell'operazione del cursore).<br /><br /> SQL_SC_UNIQUE = le garanzie di driver che simulati per gli aggiornamenti posizionati o eliminare le istruzioni interessano solo una riga. Se il driver non può garantire per una determinata istruzione **SQLExecDirect** o **SQLPrepare** restituisce un errore.<br /><br /> Se l'origine dati fornisce SQL nativo per l'aggiornamento posizionato e istruzioni delete e il driver non simulare i cursori, viene restituito SQL_SUCCESS quando SQL_SC_UNIQUE è richiesto per SQL_SIMULATE_CURSOR. Se è richiesto SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE, viene restituito SQL_SUCCESS_WITH_INFO. Se l'origine dati fornisce il livello SQL_SC_TRY_UNIQUE di supporto e non il driver, viene restituito SQL_SUCCESS per SQL_SC_TRY_UNIQUE e SQL_SUCCESS_WITH_INFO viene restituito per SQL_SC_NON_UNIQUE.<br /><br /> Se il tipo di simulazione di cursore specificato non è supportato dall'origine dati, il driver sostituisce un tipo diverso di simulazione e restituisce SQLSTATE 01S02 (valore di opzione modificato). Per SQL_SC_UNIQUE, il driver sostituisce, in ordine, SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE. Per SQL_SC_TRY_UNIQUE, il driver sostituisce SQL_SC_NON_UNIQUE.<br /><br /> Il valore predefinito è SQL_SC_UNIQUE.<br /><br /> Per ulteriori informazioni, vedere [la simulazione di aggiornamento posizionato e comandi Delete](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Un valore SQLULEN che specifica se un'applicazione utilizzerà i segnalibri con un cursore:<br /><br /> SQL_UB_OFF = Off (impostazione predefinita)<br /><br /> SQL_UB_VARIABLE = segnalibri userà un'applicazione con un cursore e il driver fornirà segnalibri a lunghezza variabile se sono supportate. SQL_UB_FIXED è deprecato in ODBC 3*x*. ODBC 3*x* le applicazioni devono utilizzare sempre i segnalibri di lunghezza variabile, anche quando si lavora con ODBC 2*x* driver (che è supportata solo a 4 byte di lunghezza fissa segnalibri). In questo modo un segnalibro a lunghezza fissa è semplicemente un caso speciale di un segnalibro a lunghezza variabile. Quando si lavora con un ODBC 2*x* driver, Driver Manager esegue il mapping SQL_UB_VARIABLE a SQL_UB_FIXED.<br /><br /> Per utilizzare i segnalibri con un cursore, l'applicazione deve specificare questo attributo con il valore SQL_UB_VARIABLE prima dell'apertura del cursore.<br /><br /> Per ulteriori informazioni, vedere [il recupero dei segnalibri](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] queste funzioni possono essere chiamate in modo asincrono, solo se il descrittore è un descrittore di implementazione, non è un descrittore di applicazione.  
  
 Vedere [associazione per colonna](../../../odbc/reference/develop-app/column-wise-binding.md) e [l'associazione per riga](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funzioni correlate  
  
|Per informazioni su|Vedere|  
|---------------------------|---------|  
|L'elaborazione di istruzione di annullamento|[Funzione SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Restituisce l'impostazione di un attributo di connessione|[Funzione SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Restituisce l'impostazione di un attributo di istruzione|[Funzione SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|L'impostazione di un attributo di connessione|[Funzione SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Impostazione di un singolo campo del descrittore|[Funzione SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Vedere anche  
 [Riferimento all'API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [File di intestazione ODBC](../../../odbc/reference/install/odbc-header-files.md)
